sec01. 인터페이스 역할
인터페이스는 두 객체를 연결하는 역할

                인
                터        (객체 B)
  <객체 A>       페    
                이        (객체 C)
                스
                
객체 A, B, C가 있다고 가정하고.
만약 인터페이스 없이 <객체 A>가 (객체 B)를 직접 사용하는 와중 (객체 B)가 (객체 C)로 변경된다 하자. <객체 A>의 소스 코드를 (객체 B)에서 (객체 C)로 변경하는 작업이 추가적으로 필요.
<객체 A>가 인터페이스의 메소드를 호출하면 실제로 실행되는 것은 인터페이스 뒤편의 (객체 B)또는 (객체 C)의 메소드 일 것.

sec02. 인터페이스와 구현 클래스 선언
인터페이스는 '~.java' 형태의 소스 파일로 작성되고 '~.class'형태로 컴파일 되기 때문에 물리적 형태는 클래스와 동일. 단, 소스를 작성할 때 선언하는 방법과 구성 멤버가 클래스와 다름.

인터페이스 선언은 class 키워드 대신 interface 키워드를 사용
- 문법
  interface 인터페이스명 { --- }        //default 접근 제한 
  public interface 인터페이스명 { --- } //public 접근 제한
  
- 선언할 수 있는 멤버의 종류
  public interface 인터페이스명 {
    //public 상수 필드
    //public 추상 메소드
    //public 디폴드 메소드
    //public 정적 메소드
    //private 메소드
    //private 정적 메소드
  }

구현 클래스 선언
  <객체 A>가 인터페이스의 추상 메소드를 호출하면 인터페이스는 (객체 B)의 메소드를 실행함. 그러기 위해선, (객체 B)는 인터페이스에 선언된 추상 메소드와 동일한 선언부를 가진 메소드를 가지고 있어야 함.
- 문법
  public class B implements 인터페이스명 { --- }
(객체 B)를 인터페이스를 구현한 객체
implements 키워드는 해당 클래스가 인터페이스를 통해 사용할 수 있다는 표시이며, 인터페이스의 추상 메소드를 재정의한 메소드가 있다는 뜻

인터페이스도 하나의 타입이므로 변수의 타입으로 사용 가능. 인터페이스는 참조 타입에 속하므로 인터페이스 변수에는 객체를 참조하고 있지 않다는 뜻으로 null을 대입 할 수 있음.
  RemoteControl rc;
  RemoteControl rc = null;
  
인터페이스를 통해 구현 객체를 사용하여면, 인터페이스 변수에 구현 객체(번지)를 대입해야 함.
  rc = new Television();
Television 객체를 생성하고 번지를 대입하는 코드.

Television 클래스는 RemoteControl 인터페이스를 구현하고 있으므로 Television 객체를 직접 RemoteControl 변수 rc에 대입할 수 있음.
  rc.turnOn();
인터페이스 변수를 통해 turnOn() 메소드가 호출되면, 실제로 실행되는 것은 Television에서 정의된 turnOn() 메소드.

sec03. 상수 필드
인터페이스는 public static final 특성을 갖는 불변의 상수 필드를 멤버로 가질 수 있음.
- 문법
  [public static final] 타입 상수명 = 값;
인터페이스에 선언된 필드는 모두 public static final 특성을 갖기 때문에 생략하더라도 자동적으로 컴파일 과정에서 붙게 됨.

sec04. 추상 메소드
인터페이스는 구현 클래스가 재정의해야 하는 public 추상 메소드를 멤버를 가질 수 있음.
추상 메소드는 리턴 타입, 메소드명, 매개변수만 기술되고 중괄호 {}를 붙이지 않는 메소드를 말함.
- 문법
  [public abstract] 리턴타입 메소드명( 매개변수, ---);
public abstract를 생략하더라도 컴파일 과정에서 자동으로 붙게 됨.
추상 메소드는 객체 A가 인터페이스를 통해 어떻게 메소드를 호출할 수 있는지 방법을 알려주는 역할.

인터페이스 구현 객체 B는 추상 메소드의 실행부를 갖는 재정의된 메소드가 있어야 함.

주의할 점
  인터페이스의 추상 메소드는 기본적으로 public 접근 제한. 따라서 재정의할 때 public보다 더 낮은 접근 제한으로 재정의 불가. 그래서 재정의되는 메소드에는 모두 public이 추가되어 있음.

인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입되면 구현 객체의 번지를 저장.
RemoteControl rc;                   RemoteControl rc = new Audio();
rc = new Television();

구현 객체가 대입되면 인터페이스 변수로 추상 메소드를 호출 할 수 있는데, 어떤 구현 객체가 대입되었는지에 따라 실행 내용이 달라짐.

sec05. 디폴트 메소드
  추상 메소드는 실행부(중괄호 {})가 없지만, 디폴트 메소드는 실행부가 있음.
선언 방법은 클래스 메소드와 동일하나, 차이점은 default 키워드가 리턴 타입 앞에 붙음.
- 문법
  [public] default 리턴타입 메소드명( 매개변수, --- ) { --- }
실행부에는 상수 필드를 읽거나 추상 메소드를 호출하는 코드를 작성할 수 있음.
구현 클래스는 디폴트 메소드를 재정의해서 자신에게 맞게 수정할 수 있음.

재정의 시 주의할 점
  public 접근 제한자를 반드시 붙이고, default 키워드를 생략해야 함.

sec06. 정적 메소드
정적 메소드는 구현 객체가 없어도 인터페이스만으로 호출할 수 있음.
선언 방법은 클래스 정적 메소드와 완전 동일. public을 생략하더라도 자동으로 붙는 것이 차이점.
- 문법
  [public | private] static 리턴타입 메소드명( 매개변수, --- ) { --- }
  
실행부(중괄호{ })를 작성할 때 주의할 점은 상수 필드를 제외한 추상 메소드, 디폴트 메소드, private 메소드 등을 호출할 수 없음. 구현 객체가 필요한 인스턴스 메소드이기 때문

sec07. private 메소드
인터페이스의 상수 필드, 추상 메소드, 디폴트 메소드, 정적 메소드는 모두 public 접근 제한을 갖음.
이 멤버들은 선언할 때 public을 생략하더라도 컴파일 과정에서 자동으로 public 접근 제한자가 붙어 항상 외부에서 접근이 가능.
또한, 외부에서 접근할 수 없는 private 메소드 선언도 가능
 - private 메소드        > 구현 객체가 필요한 메소드      > 디폴트 메소드 안에서만 호출이 가능
 - private 정적 메소드   > 구현 객체가 필요 없는 메소드    > 디폴트 메소드뿐만 아니라 정적 메소드 안에서도 호출이 가능

private 메소드의 용도 - 디폴트와 정적 메소드들의 중복 코드를 줄이기 위함.

sec08. 다중 인터페이스 구현
구현 객체는 여러 개의 인터페이스를 implements 할 수 있음. 구현 객체가 인터페이스 A와 인터페이스 B를 구현하고 있으면, 각각의 인터페이스를 통해 구현 객체를 사용할 수 있다.

 <객체 1>       (인터페이스 A)     
   (각 다른 인터페이스 2개)         <구현객체> (갹채 헌개)
 <객체 2>       (인터페이스 B)     

구현 클래스는 인터페이스 A, B를 implements 뒤에 쉼표로 구분해서 작성해, 모든 인터페이스가 가진 추상 메소드를 재정의 해야함.
- 문법
  public class 구현클래스명 implements 인터페이스A, 인터페이스 B {
    //모든 추상 메소드 재정의
  }
  
  (인터페이스 A)와 (인터페이스 B)를 구현한 객체는 다음과 같이 두 인터페이스 타입의 변수에 각각 대입 될 수 있음.
  - 인터페이스A 변수 = new 구현클래스명{ --- };
  - 인터페이스B 변수 = new 구현클래스명{ --- };
  구현 객체가 어떤 인터페이스 변수에 대입되느냐에 따라 변수를 통해 호출할 수 있는 추상 메소드가 결정.

sec09. 인터페이스 상속
인터페이스도 다른 인터페이스를 상속할 수 있으며, 클래스와는 다르게 다중 상속을 허용.
선언 방법은 클래스와 동일하게 extends 키워드 뒤에 상속할 인터페이스들을 나열하면 됨.
- 문법
  public interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2 { --- }
  
여기서 <자식 인터페이스>의 구현 클래스는 <자식 인터페이스>의 메소드뿐만 아니라 (부모 인터페이스)의 모든 추상 메소드를 재정의 해야 함.
구현 객체는 다음과 같이 자식 및 (부모 인터페이스) 변수에 대입될 수 있음.
자식인터페이스 변수 = new 구현클래스( --- );
부모인터페이스1 변수 = new 구현클래스( --- );
부모인터페이스2 변수 = new 구현클래스( --- );

구현 객체가 <자식 인터페이스> 변수에 대입되면 <자식> 및 (부모) 인터페이스의 추상 메소드를 모두 호출할 수 있으나, (부모 인터페이스) 변수에 대입되면 9부모 인터페이스)에 선언된 추상 메소드만 호출 가능.

sec10. 타입 변환
인터페이스의 타입 변환은 인터페이스와 구현 클래스 간에 발생. 인터페이스 변수에 구현 객체를 대입하면 구현 객체는 인터페이스 타입으로 자동 타입 변환됨.
반대로 인터페이스 타입을 구현 클래스 타입으로 변환시킬 수 있는데, 이때는 강제 타입 변환이 필요.

자동 타입 변환이란 의미 그대로 자동으로 타입 변환이 일어나는 것을 의미.
- 발생 조건
  인터페이스 변수 = 구현객체;(자동 타입 변환)

부모 클래스가 인터페이스를 구현하고 있다면 자식 클래스도 인터페이스 타입으로 자동 타입 변환될 수 있음.

interface A             A a;
B b = new B();          a = b; (O)
C c = new C();          a = c; (O)
D d = new D();          a = d; (O)
E e = new E();          a = e; (O)

강제 타입 변환이란 캐스팅 기호를 사용해서 인터페이스 타입을 구현 클래스 타입으로 변환시키는 것.
- 문법
  구현클래스 변수 = (구현클래스) 인터페이스변수;
구현 객체가 인터페이스 타입으로 자동 변환되면, 인터페이스에 선언된 메소드만 사용 가능.

interface Vehicle {                 Vehicle vehicle = new Bus();
  void run();                       
}                                   vehicle.run();          //가능
                                    vehicle.checkFare();    //불가능
class Bus implements Vehicle {      Bus bus = (Bus) vehicle;
  void run() { --- };               
  void checkFare() { --- };         bus.run();              //가능
}                                   bus.checkFare();        //가능 

sec11. 다형성
다형성이란 사용 방법은 동일하지만 다양한 결과가 나오는 성질.
다형성을 구현하기 위해서는 메소드 재정의와 자동 타입 변환 기능을 이용.
인터페이스의 추상 메소드는 구현 클래스에서 재정의를 해야 하며, 재정의되는 내용은 구현 클래스 마다 다름.
구현 객체는 인터페이스 타입으로 자동 타입 변환이 되고, 인터페이스 메소드 호출시 구현 객체의 재정의된 메소드가 호출되어 다양한 실행 결과를 얻을 수 있음.

필드의 다형성은 상속에서는 부모 타이어 클래스 타입에 자식 객체인 한국 타이어 또는 금호 타이어를 대입해서 다형성을 보여주고 있지만
부모 타입이 클래스 타입이 아니고 인터페이스라는 점이 다름.
public class Car {                  Car myCar = new Car();
  Tire tire1 = new HankookTire();   myCar.tire11 = new KumhoTire();
  Tire tire2 = new KumhoTire(); 
}
tire1, tire2필드에 어떠한 타이어 구현 객체가 대입되어도 Car 객체는 타이어 인터페이스에 선언된 메소드만 사용하므로 전혀 문제가 되지 않음.

매개변수의 다형성은 메소드 호출 시 매개값을 다양화하기 위해 상속에서는 매개변수 타입을 부모 타입으로 선언하고 호출할 때에는 다양한 자식 객체를 대입.
      <interface>
        Vehicle
   |------구현------|
  Bus             Taxi
Bus, Taxi는 Vehicle 의 매개값으로 사용
public void drive( Vehicle v ) { --- }  

sec12. 객체 타입 확인
상속에서도 객체 타입을 확인하기 위해 instanceof 연산자를 사용했는데, 인터페이스에서도 사용할 수 있음.
- 문법
  vehicle instanceof Bus
  //vehicle에 대입된 객체가 Bus일 경우 실행

메소드의 매개변수가 인터페이스 타입일 경우, 메소드 호출 시 매개값은 해당 인터페이스를 구현하는 모든 객체가 될 수 있음. 
만약, 매개값이 특정 구현 객체일 경우에만 강제 타입 변환을 하고 싶다면 instanceof 연산자를 사용해 매객값의 타입을 검사.

sec13. 봉인된 인터페이스
무분별한 자식 인터페이스 생성을 방지하기 위해 봉인된 인터페이스가 도입.
-문법
  public sealed interface InterfaceA permits InterfaceB
InterfaceA의 자식 인터페이스는 InterfaceB만 가능.
sealed 키워드를 사용하면 permits 키워드 뒤에 상속 가능한 자식 인터페이스를 지정해야 함.

봉인된 InterfaceA를 상속하는 InterfaceB는 non-sealed 키워드로 다음과 같이 선언하거나, sealed 키워드를 사용해서 또 다른 봉인 인터페이스로 선언.
  public non-sealed interface InterfaceB extends InterfaceA { --- }
non-sealed는 봉인을 해제한다는 뜻. 따라서 InterfaceB는 다른 자식 인터페이스를 만들 수 있음.
